library(shiny)
library(shinythemes)
library(httr)
library(jsonlite)
library(DT)
library(shinyWidgets)


source("helpers.R")

testdf <- read.csv('c:/temp/df.csv', stringsAsFactors = F)
serverLoc <- 'http://127.0.0.1:6902'
#server <- 'http://esoil.io/TERNLandscapes/SoilDataFederatoR/R'

url <- paste0(serverLoc, '/SoilDataAPI/Providers')
providerList <- fromJSON(url)

print(getwd())


insertRow <- function(existingDF, newrow, r) {
  existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
  existingDF[r,] <- newrow
  existingDF
}

blankResponseDF <- function(){

  outDF <- data.frame(Provider=character(), Dataset=character(), Observation_ID=character(), SampleID=character(), SampleDate=character() ,
                      Longitude=numeric() , Latitude= numeric(),
                      UpperDepth=numeric() , LowerDepth=numeric() , PropertyType=character(), ObservedProperty=character(), Value=numeric(),
                      Units= character(), Quality=integer(), stringsAsFactors = F)
}


# Define UI for random distribution app ----
ui <- fluidPage(
    titlePanel("SoilDataFederator"),

    tags$style(appCSS),


    theme = shinytheme("flatly"),


    # App title ----
  #  titlePanel(HTML("<img src=soilcores2.PNG style='vertical-align: top;'>")),

    # Sidebar layout with input and output definitions ----
    sidebarLayout(

        # Sidebar panel for inputs ----
        sidebarPanel(
             fluidRow(textInput('authusr', 'User Name', value='ross.searle@csiro.au' )),
             fluidRow(passwordInput('authkey', 'API key', value='a')),
            fluidRow(selectInput('currentProvider', 'Select a Provider', choices = c('All', providerList$OrgFullName))),
            fluidRow(selectInput('propTypes', 'Select a Provider', choices = c('FieldMeasurement', 'LaboratoryMeasurement'), selected='LaboratoryMeasurement')),
            fluidRow(selectInput('propGrps', 'Property Groups', choices = NULL)),
            fluidRow(selectInput('propObs', 'Observed Property', choices = NULL)),
            tags$br(),
            progressBar(
                id = "pb",
                value = 0,
                total = 100,
                title = "Test",
                display_pct = TRUE
            ),

       # withBusyIndicatorUI(
            actionButton("getData2","Get Data", class = "btn-success")
       #)

        ),

        # Main panel for displaying outputs ----
        mainPanel(

            # Output: Tabset w/ plot, summary, and table ----
            tabsetPanel(type = "tabs",
                        tabPanel("Data",
                                 #rHandsontableOutput("dataTab")
                                 DT::dataTableOutput("dataTab")),
                        tabPanel("Summary", verbatimTextOutput("summary"),
                                 htmlOutput("SummaryText"),
                                 rHandsontableOutput("summaryTab"),
                                 plotOutput('dplot'),
                                 plotOutput('bplot'),
                                 rHandsontableOutput("perProvTab")


                                 ),
                        tabPanel("Map",
                                 leafletOutput("sitesMap", width = "750", height = "550"))
            )

        )
    )
)

# Define server logic for random distribution app ----
server <- function(session, input, output) {

    RV <- reactiveValues()
    RV$currentdata = NULL

    observe({

      RV$currentdata <- testdf
    })

    output$sitesMap <- renderLeaflet({

      req(RV$currentdata )

      df <- as.data.frame(RV$currentdata)
      frows <- df %>% group_by(Provider, Dataset, Observation_ID) %>% filter(row_number()==1)
      df.SP <- st_as_sf(frows, coords = c("Longitude", "Latitude"), crs = 4326)

      head(df.SP)

      pal <- colorNumeric(c("red", "green", "blue"), domain = df.SP$Value)

      leaflet() %>%
        addTiles() %>%
        addProviderTiles("Esri.WorldTopoMap", group = "Topo") %>%
        addProviderTiles("Esri.WorldImagery", group = "ESRI Aerial") %>%
        addCircleMarkers(data=df.SP, group='Soil pH', radius = 2, opacity=1,
                         stroke=F,
                         fillOpacity = 1,
                         weight=1,
                         #fillColor = "yellow",
                         color = ~pal(df.SP$Value),
                         popup = paste0("Site ID : ", df.SP$Observation_ID ,
                                        "<br> Attribute : ", df.SP$ObservedProperty ,
                                        "<br> Value : ", df.SP$Value )) %>%
        addLegend("topright", pal = pal, values = df.SP$Value,
                  title = "Soil Data",
                  #labFormat = labelFormat(prefix = "$"),
                  opacity = 1
        ) %>%
        addLayersControl(
          baseGroups = c("Topo","ESRI Aerial"),
          overlayGroups = c("Soil Data"),
          options = layersControlOptions(collapsed = T))
    })

    output$SummaryText <- renderText({
      paste0('<p></p><p style="color:green;font-weight: bold;">Summary Statistics for ',   input$propObs, '</p>' )
    })

    output$summaryTab = renderRHandsontable({
      req(RV$currentdata )

      s<- RV$currentdata$Value
      dfs <- data.frame(label=character(6), other=character(6), stringsAsFactors = F)
      dfs[1,] <- c('Min Value ',s[1])
      dfs[2,] <- c('1st Quartile ',s[2])
      dfs[3,] <- c('Median ' ,s[3])
      dfs[4,] <- c('Mean ' ,s[4])
      dfs[5,] <- c('3rd Quartile ' ,s[5])
      dfs[6,] <- c('Max value ',s[6])
      validCnt <- length(which(!is.na(df$Value)))
      naCnt <- length(which(is.na(df$Value)))
      dfs[7,] <- c('Locations', length(unique(df$Observation_ID)))
      dfs[8,] <- c('Records', nrow(df))
      dfs[9,] <- c('Valid Vals', validCnt)
      dfs[10,] <- c('NA Vals', naCnt)

      rhandsontable(dfs , manualColumnResize = T, readOnly = TRUE, rowHeaders = F)
    })

    output$perProvTab = renderRHandsontable({
      req(RV$currentdata )
      dfs<-setDT(df)[ , list(mean = mean(Value) ,median = median(Value), q10 = quantile(Value, 0.1), q90 = quantile(Value, 0.9)) , by = .(Provider)]
      rhandsontable(dfs , manualColumnResize = T, readOnly = TRUE, rowHeaders = F)
    })



    output$dataTab = DT::renderDataTable({
        RV$currentdata
    })
    observe({

        req(input$propTypes)
        url <- paste0(serverLoc, '/SoilDataAPI/PropertyGroups')
        resp <- fromJSON(url)
        vals <- resp[resp$PropertyType == input$propTypes, ]
        updateSelectInput(session, "propGrps", choices = sort(vals$PropertyGroup), selected = 'PH')
    })


    observe({

        req(input$propGrps)

        url <- paste0(serverLoc, '/SoilDataAPI/Properties?PropertyGroup=', input$propGrps)
        print(url)
        resp <- fromJSON(url)
        print(head(resp))

        updateSelectInput(session, "propObs", choices = paste0(resp$Property), selected = '4A1')
    })


    observeEvent(input$getData2, {

            if(input$currentProvider == 'All'){
                provs <- providerList$OrgName
            }
            else{
                provs = providerList[providerList$OrgFullName == input$currentProvider, 1]
            }
            #outDF <- data.frame(stringsAsFactors = f)

            outdfs <- list(length(provs))

            for(i in 1:length(provs)){

              updateProgressBar(
                session = session,
                id = "pb",
                value = i, total = length(provs),
                title = paste("Getting data from ", provs[i])
              )

                url <- paste0(serverLoc, '/SoilDataAPI/SoilData?observedProperty=', input$propObs, '&providers=', provs[i], '&usr=', input$authusr, '&key=', input$authkey)
               # url <- paste0('http://esoil.io/TERNLandscapes/SoilDataFederatoR/R/SoilDataAPI/SoilData?observedProperty=3A1&providers=', provs[i])

                 print(url)
                odf <- fromJSON(url)


                if(is.data.frame(odf))
                {
                  outdfs[[i]] <- odf
                }else{
                  outdfs[[i]] <- blankResponseDF()
                }

            }

            df = as.data.frame(data.table::rbindlist(outdfs, fill=T))


            df$Value <- as.numeric(as.character(df$Value))
            df <- df[!is.na(df$Value),]

            # Is With Australia Bounding Box
            xmin=113.3;ymin=-43.7;xmax=153.6;ymax=-10.6
            outdf <- df[df$Longitude >= xmin & df$Longitude <= xmax & df$Latitude >= ymin & df$Latitude <= ymax, ]

            # Is within reasonable value range
            outDF <- outdf[outdf$Value > 0 & outdf$Value < 12, ]

            updateProgressBar(
              session = session,
              id = "pb",
              value = 0, total = length(provs),
              title = paste("Done")
            )

        RV$currentdata <- outDF
       # print(resp)

    })


    output$bplot<-renderPlot({
        df <- RV$currentdata
        ggplot(df, aes(x=Provider, y=Value)) + geom_boxplot() + theme(axis.text.x  = element_text(angle=90, vjust=0.5))
    })

    output$dplot<-renderPlot({

      df <- RV$currentdata
      d <- density(df$Value)
      plot(d, main=paste0("Data Distribution for ",  input$propObs))
      polygon(d, col="blue", border="blue")


    })

}

# Create Shiny app ----
shinyApp(ui, server)
